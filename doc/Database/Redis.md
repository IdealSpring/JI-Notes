## 目录

- [1.什么是Redis？](#1什么是Redis)
- [2.为什么用Redis缓存？](#2为什么用Redis缓存)
- [3.Redis为什么是单线程的？](#3Redis为什么是单线程的)
- [4.数据类型？](#4数据类型)
- [5.Redis为什么那么快？](#5Redis为什么那么快)
- [6.Redis和Memcached区别？](#6Redis和Memcached区别)
- [7.Redis提供的淘汰策略？](#7Redis提供的淘汰策略)
- [8.持久化两种方式？](#8持久化两种方式)
- [9.缓存穿透及其解决？](#9缓存穿透及其解决)
- [10.缓存雪崩及其解决？](#10缓存雪崩及其解决)
- [11.缓存击穿及其解决？](#11缓存击穿及其解决)
- [12.基于Redis分布式锁实现？](#12基于Redis分布式锁实现)
- [13.如何解决并发竞争Key？](#13如何解决并发竞争Key)
- [14.Redis和数据库是怎么保持一致性的？](#14Redis和数据库是怎么保持一致性的)
- [15.使用场景](#15使用场景)

---

### 1.什么是Redis？

Redis是速度非常快的非关系型内存键值数据库，可以存储键和五中不同数据类型的值之间的映射。

### 2.为什么用Redis缓存？

高性能和高并发；

高性能：用户第一次访问数据库中的某些数据可能会慢一些，因为这个过程需要查询数据库，再将数据放到内存中。这样下一次再次查询这些数据的时候就可以直接从内存中获取，因为是操作内存，所以速度非常开。

高并发：直接操作内存能够承受的访问量是远远高于访问数据库的，一部分用户的请求直接到内存中获取数据，这样大大的提高系统的并发量。

### 3.Redis为什么是单线程的？

官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。

单线程情况下已经很快了，就没有必要使用多线程了。

### 4.数据类型？

它是Key-Value键值数据库，键只能是字符串类型，值有五中数据类型：字符串、列表、集合、散列、有序集合。

### 5.Redis为什么那么快？

1）完全基于内存，绝大部分请求都是基于内存的操作。

2）使用键值对，数据结构简单。

3）采用单线程，避免了不必要的上下文切换和加锁释放锁操作，也不存在多线程切换而消耗CPU资源。

4）使用IO多路复用，非阻塞IO。(“多路”指的是多个网络连接，“复用“指的是复用同一个线程)

### 6.Redis和Memcached区别？

1）Redis支持字符串等五种数据类型，而Memcached只支持字符串。

2）Redis支持RDB和AOF两种持久化策略，而Memcached不支持内存数据持久化。

3）Redis支持分布式部署，而Memcached不支持。

### 7.Redis提供的淘汰策略？

六中缓存淘汰策略：

1）从已设置过期时间的数据集中挑选最近最少使用的数据淘汰；

2）从已设置过期时间的数据集中挑选将要过期的数据淘汰；

3）从已设置过期时间的数据集中任意选择淘汰数据；

4）从所有数据集中挑选最近最少使用的数据淘汰；

5）从所有数据集中任意选择淘汰数据；

6）不淘汰数据；

### 8.持久化两种方式？

RDB和AOF两种；

RDB通过创建快照来获得内存中数据在某个时间点上的副本；

AOF默认是关闭的，开启后会将Redis数据库中执行的命令写入硬盘中的AOF文件中，它有三种方式，每次修改都会写入文件、每秒钟写入文件一次、让系统决定持久化时间。

### 9.缓存穿透及其解决？

缓存击穿指查询一个数据库一定不存在数据，由于缓存中没有，需要到数据中查询，数据库中也没有，查询完就无法写入到缓存，如果大流量时，DB可能就挂掉了。

如果数据库查询为空，仍然将空值进行缓存。

### 10.缓存雪崩及其解决？

缓存雪崩指对键值对设置了相同的过期时间，导致在某一时刻同时失效，所有请求全部转发到DB，导致DB崩溃。

可以再原有的过期时间的基础上增加一个随机值，这样缓存过期时间重复率就会降低，就很难引发集体失效。

### 11.缓存击穿及其解决？

缓存在某个key过期的时候，恰恰在这个时间点对这个key有大量的请求发过来，这个请求发现缓存过期一般从数据库加载并回设到内存，这时候大量的请求可能会瞬间把后台数据库压垮。

使用互斥锁实现。

### 12.基于Redis分布式锁实现？

使用Redis的setnx命令去设置一个key-value，当操作成功时返回true失败时返回false，可以利用带返回值的操作来实现基于Redis的分布式锁。

### 13.如何解决并发竞争Key？

使用分布式锁。

### 14.Redis和数据库是怎么保持一致性的？

将对同一个键值的读请求和写请求串行化，串到一个内存队列里去，在去操作内存和数据库，这样就可以保证一定不会出现不一致的情况，但是串行化之后，就会导致系统的吞吐量会大幅度的降低。

1）它最主要的用处是缓存：将热点数据缓存到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率；

2）在分布式场景下，可以实现分布式锁；