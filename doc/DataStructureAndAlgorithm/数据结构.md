## 目录

- [1.讲一讲队列？](#1讲一讲队列)
- [2.讲一讲栈？](#2讲一讲栈)
- [3.讲一讲二叉树？](#3讲一讲二叉树)
- [4.讲一讲堆？](#4.讲一讲堆)
- [5.讲一讲AVL树？](#5讲一讲AVL树)
- [6.讲一讲红黑树？](#6讲一讲红黑树)
- [7.讲一讲B树？](#7讲一讲B树)
- [8.讲一讲B+树？](#8讲一讲B树)

---

### 1.讲一讲队列？

队列是一种FIFO（First-In-First-Out）先进先出线性结构；在尾部添加元素，在头部取出元素。

队列有三种：单向队列、双向队列和循环队列。

Java中LinkedList集合底层使用双向队列实现，balabala一堆。

### 2.讲一讲栈？

栈是一种先进后出的结构；有压栈和出栈两种操作。

Java中Stack是对栈数据结构的实现，它底层使用Vector集合实现的，balabala一堆。

### 3.讲一讲二叉树？

二叉树是每个节点最多只有两个分支的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。

### 4.讲一讲堆？

在一棵二叉树中，每个节点的值大于左孩子和右孩子的值，这样的二叉树称作大根堆；同理，每个节点的值小于其左右孩子的值，称作小根堆。

### 5.讲一讲AVL树？

在数据结构中，AVL是最先被发明的自平衡二叉树。在AVL树中，任何节点的左子树和右子树的高度差不能超过1，它是高度平衡的二叉树。它的插入、删除和查找操作的最坏时间复杂度是O（logn）。

在AVL树中，插入和删除操作可能会引起不平问题；可以通过对树的左右旋转，将其修正成平衡二叉树。解决不平衡方式有一下四类：

**左左：** 插入节点在失衡节点左孩子的左子支上。解决方式是：以失衡节点的父节点为轴，顺时针旋转一个节点；也就是将失衡节点作为其左子节点的右孩子，如果那个左子节点有右孩子，则将这个右孩子过继给失衡节点，作为其左孩子。

**右右：** 插入节点在失衡节点右孩子的右子树上。解决方式是：以失衡节点的父节点为轴，逆时针旋转一个节点；也就是将失衡节点作为其右子节点的左孩子，如果那个右子节点有左孩子，则将这个左孩子过继给失衡节点，作为其右孩子。

**左右：** 插入节点在失衡节点左孩子的右子树上。解决方式是：以失衡节点为轴，逆时针旋转一个节点，也就是将失衡节点的左孩子作为其的右孩子的左孩子，如果这个右孩子有左孩子，就将其过继给失衡节点的左孩子，并坐其右孩子，这样就将左右的情况转化成左左的情况，之后再进行左左操作就可以了。

**右左：** 插入节点在失衡节点右孩子的左子树上。解决方式是：以失衡节点为轴，顺时针旋转一个节点，并将节点过继，转化成右右的情况的情况，之后再进行右右操作就可以了。

### 6.讲一讲红黑树？

红黑树是一种自平衡二叉树，和AVL树相比，它对平衡的要求较低，而AVL树是严格的平衡二叉树，这样红黑树用在平衡处理的系统消耗就会比AVL树低很多。

红黑树具有以下性质：

1）每个节点不是红色就是黑色。

2）根节点永远为黑色。

3）左右叶子结点都是黑色且值为空。

4）红节点的两个子节点必须为黑色，而黑节点的两个子节点不一定要为红。

5）从根节点到所有叶子结点最短路径中的黑节点数相同。

满足这几条性质的树，就是红黑树。

插入或者删除节点可能会使树失衡，对红黑树的修正方式分为几种情况：

1）插入节点后，该节点为根节点，那么直接将其颜色变成黑色即可。因为插入的节点默认是红色。

2）插入节点的父节点和叔节点均为黑色，那么不需要修正。

3）插入节点的父节点和叔节点都是红色，将插入节点的父节点和叔节点均变成黑色，就可修正红黑树。

4）插入节点的父节点是红色，叔节点是黑色；这种情况又分为两种，一种是插入节点是父节点的左孩子，另一种是插入节点是父节点的右孩子；我们讨论一下相对较复杂的第二种情况，插入节点是父节点的右孩子，修正操作分为两步：**第一步** 将插入节点和父节点逆时针旋转，并将插入节点的左孩子过继给父节点，这样就转化成第一种情况， 此时父节点和子节点的关系发生了调换，父节点成了子节点，子节点成了父节点。**第二步**  再以祖父节点为轴，顺时针旋转整体，并过继相应节点，之后再改变父节点为黑色，以前的祖父节点为红色。此时，修正完事，红黑树有恢复平衡。

### 7.讲一讲B树？

B树主要用于文件系统和索引，一个m阶B树具有如下性质：

1）每个节点最多有m个子节点。

2）每个非叶子节点最少有 m/2 个子节点，根节点除外。

3）如果根节点不是叶子节点，它最少有两个子节点。

4）k个子节点的非叶子节点拥有k-1个键。

5）所有的叶子节点都在同一层上。

### 8.讲一讲B+树？

