## 目录

- [1.JVM运行时内存划分？](#1JVM运行时内存划分)

- [2.内存溢出和内存泄漏区别？](#2内存溢出和内存泄漏区别)

- [3.对象的创建过程？](#3对象的创建过程)

- [4.内存分配两种方式？](#4内存分配两种方式)

- [5.对象的访问定位两种方式？](#5对象的访问定位两种方式)

- [6.对象头的布局？](#6对象头的布局)

- [7.类的生命周期？](#7类的生命周期)

- [8.类的加载过程？](#8类的加载过程)

- [9.类的初始化时机？](#9类的初始化时机)

- [10.讲讲双亲委派模型？](#10讲讲双亲委派模型)

- [11.如何判断对象可被回收？](#11如何判断对象可被回收)

- [12.如何判断常量是废弃常量？](#12如何判断常量是废弃常量)

- [13.如何判断类是无用类？](#13如何判断类是无用类)

- [14.引用类型？](#14引用类型)

- [15.讲一讲垃圾收集算法？](#15讲一讲垃圾收集算法)

- [16.讲讲Serial收集器、CMS收集器和G1收集器？](#16讲讲Serial收集器CMS收集器和G1收集器)

- [17.什么是Minor GC和Full GC？](#17什么是Minor-GC和Full-GC)

- [18.内存分配策略？](#18内存分配策略)

- [19.Full GC出发条件？](#19Full-GC出发条件)

---

### 1.JVM运行时内存划分？

线程私有的程序计数器、Java虚拟机栈、本地方法栈；

线程共有的堆、方法区。

### 2.内存溢出和内存泄漏区别？

内存溢出：现有内存不够使用叫内存溢出；

内存泄漏：在对象中，由于某些操作导致一些没有必要占用的内存资源没有及时释放，从而导致内存不够用。

### 3.对象的创建过程？

类加载和检查 --> 分配内存 --> 初始化零值 --> 设置对象头 --> 执行init方法

1）类的加载检查：当虚拟机遇到new指令时，首先去检查这个命令参数是否能在常量池中找到类的符号引用，并检查这个类是否已经被加载、检验、准备、解析、初始化，如果没有首先执行类加载。

2）内存分配：虚拟机为这个对象在堆中分配内存，主要有指针碰撞方法和空闲列表法。

3）初始化零值：将分配到的内存空间初始化零值，这保证每个java变量在初始化后就可以直接使用。

4）设置对象头：设置对象的哈希值、GC分代年龄、锁状态、对象类型指针等。

5）执行init方法：执行对象的初始化方法。

### 4.内存分配两种方式？

**指针碰撞：**适合使用在内存规整，没有碎片的情况下。将内存分为两部分，一部分是正在使用的内存，另一部分是空闲内存，中间是位置指针，当分配空间时，指针想空闲区域移动对象所需内存大小。内存规不规整，取决于垃圾收集器，Serial收集器，是新生代垃圾收集器，使用的是复制算法进行垃圾回收，复制算法将新生代分成大小相等的两块，一次只用其中一块内存，这块内存用完时，将这块中还存活的对象复制到另一块没用的内存，然后把使用的内存一次性清理掉，hotspot虚拟机在新生代使用复用算法，但是他没有将内存分成大小相等的两部分，而是三部分，eden区，from survivor，to survivor区，大小比例为8:1:1，每次使用eden和from survivor两块区域，等代存回收时，将存活的对象复制到to survivor区。

**空闲列表法：**适合内存不规整的情况下，他维护一个列表，记录空闲的内存块，当分配内存时从空闲列表中找出相应的内存块。CMS垃圾收集器。

### 5.对象的访问定位两种方式？

指针访问：通过指针找到对象实例，再通过对象找到对象类型。

句柄池访问：先找到句柄池，再通过句柄池找到对象实例和对象类型。

### 6.对象头的布局？

包含两部分：第一部分存储自身运行时数据，哈希值、GC分带年龄、锁状态；第二部分，类型指针。

### 7.类的生命周期？

加载 --> 验证 --> 准备 --> 解析 --> 初始化

### 8.类的加载过程？

加载：通过二进制字节码问价，加载类的class文件。

验证：验证这个字节码文件是否符合Class文件规范等。

准备：初始化类的变量，也就是static修饰的变量和方法，这属于类。

解析：将常量池中的符号引用替换成直接引用。

初始化：初始类变量和其他资源。

### 9.类的初始化时机？

遇到new、putstatic、getstatic、invokestatic这几个字节码指令，balabala一堆。

被反射包调用时，如果类没有初始化，要对类进行初始化。

初始化一个类时，如果其父类没有被初始化，先对父类进行初始化。

启动虚拟机时，初始化main方法所在的类。

### 10.讲讲双亲委派模型？

**类加载器分类：**

启动类加载器：它是虚拟机的一部分使用C++语言实现，用来初始化lib包下的类。其他的类加载器使用的java语言实现。

扩展类加载器：用来初始化lib/ext包的类。

应用程序类加载器：用来初始化我们写的程序。

自定义类加载器：自己定义的类加载器。



**Java的类加载机制是双亲委派模型：**

自低向上，双亲委派关系是自定义类加载器，应用程序类加载器、扩展类加载器、启动类加载器，相邻两个加载器的关系是父子关系，这个父子关系不是通过继承实现，而是通过委派机制，也就是在子类中定义父类的变量，调用父类的方法。

类加载时，系统首先会判断类是否被加载过，如果加载过就直接返回。在类加载时，系统首先会将加载请求发送至应用程序类加载器，但是应用程序类加载器不会立即就去加载，而是将加载请求委派给其父加载器，直至委派到启动类加载器，如果他能加载，就去加载此类，如果不能，再把让其子加载器去加载。



**双亲委派模型好处：（为什么使用双亲委派模型）**

双亲委派模型保证了Java程序的稳定性，可以避免类被重复加载，保证了核心API不被篡改。

因为虚拟机区分类不只是通过类名，还有类加载器；相同类名和包名，即使通过编译器编译，但在运行还会报错。

### 11.如何判断对象可被回收？

判断对象能否被回收有两种方法：

引用计数法：用一个计数器去记录这个对象被引用的次数，被引用一次，计数器加一。当引用计数器为零，就可以回收对象。这个方法有弊端，如果两个对象中相互循环引用时，即使这个对象是无用对象，他也不会被回收。

可达性分析法：通过GC roots为起点进行搜索，可达的对象都是存活的，不可达的对象可以被回收。GC roots一般为虚拟机栈中局部变量表所引用的对象。

### 12.如何判断常量是废弃常量？

当没有指针指向这个常量，则这个常量是废弃可以被回收的常量。

### 13.如何判断类是无用类？

这个类的所有实例对象都已经被回收。

这个类的类加载器已经被回收。

这个类的Class对象没有在任何地方被引用，在任何地方无法通过反射访问该类的方法。

这个时候，这个类才有可能被回收。

### 14.引用类型？

**强引用：**

```java
Object obj = new Object();
```
使用new一个对象的方式创建的引用是强引用，强引用在任何时候都不会被回收。


**软引用：**
```java
SoftReference<Object> softReference = new SoftReference<Object>(new Object);
```

使用SoftReference类来创建软引用，软引用会在内存不够的时候被回收，内存充足时不会被回收。

**弱引用：**
```java
WeakReference<Object> weakReference = new WeakReference<Object>(new Object);
```

使用WeakReference类来创建弱引用，弱引用只能存活到下次垃圾回收。

**虚引用：**

又被成为幽灵引用，他的存在不会对对象的生命周期造成任何影响，也无法通过虚引用得到一个对象；

为对象设置虚引用的唯一目的是能在这个对象被回收的时候收到系统通知。

### 15.讲一讲垃圾收集算法？

**新生代**使用复制算法：balabala一堆。

**老年代**使用标记清除算法和标记整理算法：balabala一堆。

### 16.讲讲Serial收集器、CMS收集器和G1收集器？

**Serial:**是最悠久的新生代垃圾收集器，使用的复制算法；它是单线程的，当它工作时，会暂停所有用户线程。

它的优点是简单高效，由于它是单线程的，在单cpu环境下，没有线程切换开销，因此具有极佳的单线程收集效率。

**CMS:**它是老年代垃圾收集器，使用的标记清除算法；它是以最短的停顿时间为目的的收集器，它是hotspot真正意义上的第一款并发垃圾收集器，它第一次实现了让用户线程和垃圾收集线程基本上同时工作。

工作流程：

初始标记：仅仅标记一下GC roots能关联的直接对象，需要暂停其他线程，但是时间很短。

并发标记：通过GC roots去标记其他对象，不需要暂停其他线程，它是整个过程中最耗时的。

重新标记：修正并发标记时因用户线程工作而导致标记产生变动的那一部分对象，需要暂停其他线程，时间短。

并发清除：清除垃圾对象，需要暂停其他线程。

它的优点是并发收集、低停顿；缺点是对CPU资源敏感、无法处理浮动垃圾、使用标记清除算法会导致内存空间产生碎片。

**G1:**它是一款面向服务端的垃圾收集器，在多CPU和大内存情境下具有良好新能，他可以直接对新生代和老年代一起回收，无需其他收集器一起组合使用。

工作流程：

初始标记：同上。

并发标记：同上。

最终标记：不知。

筛选回收：不知。

优点：空间整合，从整体上看使用标记整理算法，从局部上看使用复制算法。具有可预测的停顿。

### 17.什么是Minor GC和Full GC?

Minor GC：指发生在新生代的垃圾收集动作，非常频繁，回收速度较快。

Full GF：指发生在老年代的垃圾收集动作，一般会触发一次或多次Minor GC发生，回收速度比Minor GC慢很多。

### 18.内存分配策略？

对象优先进入Eden区域。

大对象进入老年代。

长期存活对象进入老年代。

### 19.Full GC出发条件？

调用System.gc()，只是建议进行Full GC，去不去执行就不一定了。

老年代空间不足。

to Survivor区域内存担保失败，会执行一次 Full GC。