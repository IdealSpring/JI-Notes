## 目录

- [1.什么是ZooKeeper及其使用场景？](#1什么是ZooKeeper及其使用场景)
- [2.为什么最好使用奇数台服务器构成ZooKeeper集群？](#2为什么最好使用奇数台服务器构成ZooKeeper集群)
- [3.ZooKeeper底层如何实现数据一致性的？](#3ZooKeeper底层如何实现数据一致性的)
- [4.ZooKeeper如何实现分布式锁？](#4ZooKeeper如何实现分布式锁)

---

### 1.什么是ZooKeeper及其使用场景？

ZK是分布式协调服务，最初在雅虎上构建，后来成为Apache Hadoop生态系统的一部分；ZK的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语，并以一系列简单的接口提供给用户使用。

**场景：** 

- **分布式锁：** 利用ZK的临时顺序节点，可以轻松实现分布式锁；
- **数据发布与订阅：** 也就是配置中心，发布者将数据发布在ZK节点上，供订阅者动态获取数据，实现配置信息的集中管理和动态更新；
- **管理集群与Master选举：** 
    - **管理集群** 客户端在某个节点上注册监听(Watcher)，当该节点的子节点发生变化，会通知客户端(创建的节点类型为临时节点，一旦结束或过期，临时节点将消失)；
    - **Master选举** 利用ZK的强一致性特点，同时让多个客户端请求创建临时自编号顺序节点，之后选取其中编号最小的机器作为Master节点。

### 2.为什么最好使用奇数台服务器构成ZooKeeper集群？

在Zookeeper集群中，最多宕机节点个数不能超过总节点个数的一般，否则集群无法正常工作；举个例子，当集群中有5台机器的时候，最多允许宕机2台。当集群中有6台机器的时候，最多允许宕机个数也是2台。

### 3.ZooKeeper底层如何实现数据一致性？

ZAB(Zookeeper Atomic Broadcast)Zookeeper 原子广播协议定义了三种节点状态：Looking选举状态、Following Follower节点也就是从节点的状态、Leading Leader节点也就是主节点的状态。

ZAB协议有效的解决了ZK集群崩溃恢复以及主从同步数据的问题；ZAB两种模式：崩溃恢复模式和消息广播模式

**当主节点挂掉，集群会进行崩溃恢复；ZAB协议完成集群崩溃恢复分成三个阶段：** 

1）**选举阶段：** 

此时集群中的节点处于Looking选举阶段，他们各自会向相邻节点发起投票，投票中包含自己服务器的ID和最新事务ID(ZXID)；

接下来，节点会用自身的事务ID和从其他节点接收到的事务ID作比较，如果发现别人家的事务ID比自己大，也就是数据比自己新，那么就重新发起投票，投票给目前自己已知最新事务ID的所属节点；

每次投票后，服务器都会统计投票的数量，判断是否有某个节点得到半数以上的票。如果存在这样的节点，该节点将会成为准Leader，状态变为Leading，其他节点状态变为Following。

2）**发现阶段：**

发现阶段，用于在从节点中发现最新的ZXID和事务日志。或许有人会问：既然Leader被选为主节点，已经是集群里数据最新的了，为什么还要从节点中寻找最新事务呢？这是为了防止某些意外情况，比如因网络原因在上一阶段产生多个Leader的情况。

在这一阶段，准Leader接收所有Follower发来各自的最新Leader周期的epoch编号，准Leader从中选出最大的epoch编号，基于此值加1，生成新的epoch编号发送给各个从节点Followr。

各个Follower收到全新的epoch后，返回ACK给Leader，带上各自最大的ZXID和历史事务日志。Leader选出最大的ZXID，并更新自身历史日志。

3）**同步阶段：** 

同步阶段，把Leader刚才收集得到的最新历史事务日志，同步给集群中所有的Follower。只有当半数Follower同步成功，这个准Leader才能成为正式的Leader。

自此，故障恢复正式完成。



**写入数据：** 写入数据时涉及到ZAB的消息广播

在更新数据时，首先更新到主节点（这里的节点是指服务器，不是Znode），再同步到从节点。

在读取数据时，直接读取任意从节点。

1）客户端发出写入数据请求给任意Follower。

2）Follower把写入数据请求转发给Leader。

3）Leader采用二阶段提交方式，先广播事务提议(Propose)给Follower。

4）Follower接到事务提议(Propose)后，写入日志成功后，返回ACK消息给Leader。

5）Leader接到半数以上ACK消息，返回成功给客户端，并且广播Commit请求给Follower。

### 4.ZooKeeper如何实现分布式锁？

锁的实现是利用Zookeeper创建的临时序有节点(EPHEMERAL_SEQUENTIAL)和节点变动的监听器实现的。有序节点保证了节点的创建在分布式系统情况下还是有先后顺序的，监听器使得客户端能感受到节点的变动情况。

具体步骤
1、创建一个永久性节点，作锁的根目录

2、当要获取一个锁时，在锁目录下创建一个临时有序列的节点

3、检查锁目录的子节点是否有序列比它小，若有则监听比它小的上一个节点，当前锁处于等待状态

4、当等待时间超过Zookeeper session的连接时间（sessionTimeout）时，当前session过期，Zookeeper自动删除此session创建的临时节点，等待状态结束，获取锁失败

5、当监听器触发时，等待状态结束，获得锁。